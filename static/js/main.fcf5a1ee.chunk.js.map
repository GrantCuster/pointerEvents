{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["App","canvasRef","useRef","pointerRef","activePointers","p1Ref","p2Ref","p3Ref","useEffect","canvas","current","pointer","points","getOpenSlot","orders","map","order","result","length","i","includes","updatePointDisplay","point","index","indexOf","active","style","display","transform","x","y","cursor","pointerDown","e","push","id","pointerId","clientX","clientY","makePointer","setPointerCapture","pointerMove","activeIndex","activePointer","pointerUp","splice","releasePointerCapture","addEventListener","removeEventListener","ref","position","left","top","width","height","overflow","touchAction","className","right","bottom","maxWidth","pointerEvents","href","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fcf5a1ee.chunk.js","sourcesContent":["import React, { useEffect, useRef } from \"react\";\n\nfunction App() {\n  const canvasRef = useRef(null);\n  const pointerRef = useRef({\n    activePointers: [],\n  });\n  const p1Ref = useRef(null);\n  const p2Ref = useRef(null);\n  const p3Ref = useRef(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const pointer = pointerRef.current;\n    const p1 = p1Ref.current;\n    const p2 = p2Ref.current;\n    const p3 = p3Ref.current;\n    const points = [p1, p2, p3];\n\n    const getOpenSlot = (activePointers) => {\n      // Find order for new pointer\n      // This method preserves continuous touches\n      const orders = activePointers.map((pointer) => pointer.order);\n      let result = points.length;\n      for (let i = 0; i < points.length; i++) {\n        if (!orders.includes(i)) {\n          result = i;\n          break;\n        }\n      }\n      return result;\n    };\n\n    const updatePointDisplay = (activePointers) => {\n      // Use pointer data to update display\n      const orders = activePointers.map((pointer) => pointer.order);\n      for (let i = 0; i < points.length; i++) {\n        const point = points[i];\n        if (orders.includes(i)) {\n          const index = orders.indexOf(i);\n          const active = pointer.activePointers[index];\n          point.style.display = \"block\";\n          points[i].style.transform = `translate(${active.x}px, ${active.y}px)`;\n        } else {\n          point.style.display = \"none\";\n        }\n      }\n\n      // handle cursor display\n      if (activePointers.length > 0) {\n        canvas.style.cursor = \"none\";\n      } else {\n        canvas.style.cursor = \"crosshair\";\n      }\n    };\n\n    const makePointer = (e) => {\n      // Copy only the event properties we need\n      return {\n        id: e.pointerId,\n        x: e.clientX,\n        y: e.clientY,\n        order: getOpenSlot(pointer.activePointers),\n      };\n    };\n\n    const pointerDown = (e) => {\n      // Add pointer\n      pointer.activePointers.push(makePointer(e));\n\n      updatePointDisplay(pointer.activePointers);\n\n      canvas.setPointerCapture(e.pointerId);\n    };\n\n    const pointerMove = (e) => {\n      // Match move event to pointer data\n      const ids = pointer.activePointers.map((pointer) => pointer.id);\n      const activeIndex = ids.indexOf(e.pointerId);\n\n      if (activeIndex !== -1) {\n        const activePointer = pointer.activePointers[activeIndex];\n\n        // Update position\n        activePointer.x = e.clientX;\n        activePointer.y = e.clientY;\n      }\n\n      updatePointDisplay(pointer.activePointers);\n    };\n\n    const pointerUp = (e) => {\n      // Remove pointer\n      const ids = pointer.activePointers.map((pointer) => pointer.id);\n      const activeIndex = ids.indexOf(e.pointerId);\n      pointer.activePointers.splice(activeIndex, 1);\n\n      updatePointDisplay(pointer.activePointers);\n\n      canvas.releasePointerCapture(e.pointerId);\n    };\n\n    // initial hide\n    updatePointDisplay(pointer.activePointers);\n\n    canvas.addEventListener(\"pointerdown\", pointerDown);\n    canvas.addEventListener(\"pointermove\", pointerMove);\n    canvas.addEventListener(\"pointerup\", pointerUp);\n    return () => {\n      canvas.removeEventListener(\"pointerdown\", pointerDown);\n      canvas.removeEventListener(\"pointermove\", pointerMove);\n      canvas.removeEventListener(\"pointerup\", pointerUp);\n    };\n  }, []);\n\n  return (\n    <div>\n      <div\n        ref={canvasRef}\n        style={{\n          position: \"fixed\",\n          left: 0,\n          top: 0,\n          width: \"100%\",\n          height: \"100vh\",\n          overflow: \"hidden\",\n          touchAction: \"none\",\n        }}\n      >\n        <div ref={p3Ref} className=\"pointer p3\">\n          3\n        </div>\n        <div ref={p2Ref} className=\"pointer p2\">\n          2\n        </div>\n        <div ref={p1Ref} className=\"pointer p1\">\n          1\n        </div>\n      </div>\n      <div\n        style={{\n          position: \"fixed\",\n          right: 16,\n          bottom: 24,\n          maxWidth: 400,\n          width: \"calc(100% - 32px)\",\n          pointerEvents: \"none\",\n          cursor: \"crosshair\",\n        }}\n      >\n        A minimal demo exploring how to handle mouse and touch events\n        consistently using pointer events. It handles up to three touches at a\n        time. This method preserves touch order (which you may or may not want\n        to do, depending on the situation).{\" \"}\n        <a href=\"https://feed.grantcuster.com/\">View source</a>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}